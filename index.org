#+STYLE: <style> * { font-family: sans-serif; } body  { width: 700px; margin: 0 auto; } </style>
#+STYLE: <style> p { text-align: left; line-height: 1.2em; font-size: 1.1em; } li {padding-bottom: 0.2em;}</style>
#+STYLE: <style> pre, pre span { font-family: monospace; } </style>
#+STYLE: <style> code { font-family: monospace; font-size: 10pt; background-color: #EDEDED; padding: 2px;} </style>
#+STYLE: <style> th,td { border: 1px solid #ddd } </style>
#+STYLE: <style> div.figure { align: center; } </style>
#+STYLE: <style> h2 { border-bottom: 1px solid #ccc; color: #900; } body {background-color: #F8F4E7; color: #552800;}
#+STYLE: h3, h4, h5, h6 {border-bottom: 1px solid #ccc; color: #0B108C; }</style>
#+OPTIONS: _:nil
#+EMAIL: j.vimal@gmail.com

#+TITLE: EyeQ Documentation
#+AUTHOR: Vimalkumar

* What is EyeQ?
EyeQ is a distributed transport layer for your datacenter, which
provides predictable transmit _and_ receive bandwidth guarantees (over
few ms) to VMs/services on a server, without having to configure CoS
queues in your network for every VM/service.

For more details, refer to our paper:
[[http://www.stanford.edu/~jvimal/EyeQ-NSDI13.pdf]]

* Getting started
** Repositories
I maintain two repositories for EyeQ.  One is for bleeding edge
development, and the other is for releases.  The bleeding edge
contains all branches with untested and unfinished code.  The release
branch is more stable.

The stable repository is here: [[http://github.com/jvimal/eyeq]].  The
bleeding edge repository is under an older project name:
[[http://github.com/jvimal/perfiso_10g]].

** Downloading
You can clone the github repositories, which has the source code to
compile the Linux kernel module:
#+BEGIN_SRC bash
$ git clone https://github.com/jvimal/eyeq.git
#+END_SRC

** Compiling
I have tested EyeQ with Linux 3.0 and above.  EyeQ is a kernel module
that implements a queueing discpline.  So you need the kernel headers
to compile EyeQ.  You can find available headers on your system in
=/lib/modules=.

#+BEGIN_SRC bash
$ cd eyeq

$ ls /lib/modules/
3.2.0-23-generic

$ make
#+END_SRC

This will produce the performance isolation kernel module called
=perfiso.ko= for your running kernel.  If you want to compile for a
different kernel, please edit the Makefile and change the version
number accordingly.

** Installing
EyeQ hooks into the transmit path by acting as a queueing discipline.
To avoid dependency on =iproute=, EyeQ replaces the hierarchical token
bucket (=htb=) module so you can use your existing =tc= tool to
install EyeQ.  So you need to remove =htb= before you can use EyeQ.
EyeQ hooks into the receive path using =netdev_rx_handler_register=
callback.

To install EyeQ on a device:
#+BEGIN_SRC bash
$ rmmod sch_htb

$ insmod ./perfiso.ko

$ tc qdisc show
qdisc pfifo_fast 0: dev eth0 root refcnt 2 bands 3 priomap...

$ tc qdisc add dev eth0 root handle 1: htb

$ dmesg | tail
perfiso: Init TX path for eth0
perfiso: Init RX path for eth0

$ tc qdisc show
qdisc htb 1: dev eth0 root
#+END_SRC

** Usage
We provide a separate python configuration tool to work with EyeQ, as
it does not use the standard =tc= interface.  EyeQ kernel module
exports a sysfs file which it uses for all configuration mechanisms.

*** Creating tenants
EyeQ lets you filter tenants using IP addresses.  Filters are needed
to correctly classify packets to their corresponding groups for proper
resource accounting.  We use the source IP on the transmit path, and
destination IP on the receive path.  Implementing classifiers is easy,
but contact me if you need a particular classifier in EyeQ and I can
make it available.

Each tenant has a classifier and a "weight" that denotes the relative
importance of one tenant over another.  If you have two tenants A and
B with weights 1 and 2 respectively, then tenant B will get twice the
bandwidth of A whenever there is contention for bandwidth
(transmit/receive).  It is possible to set unequal weights for
transmit and receive by directly writing to EyeQ's sysfs files.

For example, to create a tenant with IP address 10.0.1.1, do:

#+BEGIN_SRC bash
$ tools/pi.py --create 10.0.1.1 --dev eth0
INFO:root:Creating txc 10.0.1.1 on dev eth0
INFO:root:Creating vq 10.0.1.1 on dev eth0
INFO:root:Setting weight of vq 10.0.1.1 on dev eth0 to 1

$ tools/pi.py --list
dev: eth0
listing TXCs
	10.0.1.1 weight 1 assoc vq 10.0.1.1
listing VQs
	10.0.1.1 weight 1
#+END_SRC

To set a different weight for tenant 10.0.1.1 on the receive path, do:
#+BEGIN_SRC bash
$ echo dev eth0 10.0.1.1 weight 10 > /sys/module/perfiso/parameters
#+END_SRC

*** Removing tenants
#+BEGIN_SRC bash
$ tools/pi.py --delete 10.0.1.1 --dev eth0
#+END_SRC

*** Parameters
EyeQ exposes a number of knobs to fine tune its operation.  In many
cases the default should just suffice.  The default parameters are
tuned for 10GbE.

#+BEGIN_SRC bash
$ tools/pi.py --get
 1           ISO_RFAIR_INCREASE_INTERVAL_US        120
 2                  IsoAutoGenerateFeedback          1
 3               ISO_TOKENBUCKET_TIMEOUT_NS      50000
 4               ISO_TXC_UPDATE_INTERVAL_US        200
... a lot more.
#+END_SRC

Stay tuned for a default set of parameters for 1GbE networks.

*** Saving and restoring configurations
You can save the config as a json file which you can restore later.

#+BEGIN_SRC bash
$ tools/pi.py --save /tmp/config
$ cat /tmp/config
{
    "params": {
        "ISO_RFAIR_INCREASE_INTERVAL_US": "120",
        "IsoAutoGenerateFeedback": "1",
        "ISO_TOKENBUCKET_TIMEOUT_NS": "50000",
...
    },
    "config": {
        "eth0": {
            "vqs": [
            ],
            "txcs": [
                {
...
                }
            ]
        }
    }
}
#+END_SRC

*** Unloading EyeQ
You can unload EyeQ by first removing each qdisc you created on
network devices.

#+BEGIN_SRC bash
$ tc qdisc del dev eth0 root
#+END_SRC

You can restore an earlier configuration by running the following as
root:

#+BEGIN_SRC bash
$ tools/pi.py --load /tmp/config
#+END_SRC


* Trying things out
The scripts used in all our experiments in the NSDI paper are
available online in the [[https://github.com/jvimal/eyeq-tests][test repository]].

** Mininet
[[http://mininet.github.com/][Mininet]] is a collection of useful scripts to configure features such
as network namespaces, containers and [[http://lartc.org/][Linux Traffic Control]], to create
lightweight virtual networks on a single machine.  I am one of the
authors of the second release of Mininet, with Bob Lantz, Brandon
Heller and Nikhil Handigol.

Mininet uses =tc= to configure =htb= inorder to emulate links with of
some capacity.  So you can use Mininet to test EyeQ as well.
Unfortunately, one of Mininet's limitations (as of 2.0) is that you
are constrained to resources that one server can offer especially CPU.
One CPU core amounts to about 2--3Gb/s of aggregate switching
capacity.  So you can try EyeQ safely with few (10) links operating at
slower link speeds, say 10--100Mb/s.

Scripts to run on Mininet forthcoming.

* Rate limiter
We have also implemented EyeQ's rate limiter, optimized for multiqueue
networking devices, as a drop-in replacement to Linux's Token Bucket
Filter (=tbf=).  You can download it from the ptb repository:
[[https://github.com/jvimal/ptb]].

** Obtaining, Compiling and Installing
Since =ptb= is a drop-in replacement for =tbf=, you will have to
remove =tbf= from a running kernel before you can use =ptb=.  The
module is for Linux kernels 3.7 onwards, as the qdisc API
datastructures changed a bit.  However, the API change is simple so
you can easily port it to older kernels.

#+BEGIN_SRC bash
$ rmmod sch_tbf
$ git clone https://github.com/jvimal/ptb.git
$ cd ptb
$ make
$ insmod ./sch_ptb.ko
#+END_SRC

There is a sample script with default options so you can test PTB out.
Just like Linux's default =mq= or =mqprio= qdisc, =ptb= must be the
root qdisc.  It cannot be the child of any other qdisc.

#+BEGIN_SRC bash
$ cat tc.sh
#!/bin/bash

dev=eth2
tc qdisc del dev $dev root
rmmod sch_ptb
make
insmod ./sch_ptb.ko
tc qdisc add dev $dev root handle 1: tbf limit 100000 burst 1000 rate 3Gbit
#+END_SRC
